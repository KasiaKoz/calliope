constraints:


    carrier_production_max: # alice - is that it?
      foreach: [node, tech, timestep]
      eq: carrier_prod <= energy_cap * timestep_resolution * parasitic eff


    balance_supply: # kasia
        foreach: [carrier, node, tech, timestep]
        eq:
          - if: energy_eff == 0
            then: carrier_prod == 0
          - if: force_resource == 1
            then: carrier_prod_div_energy_eff == available_resource
          - if: min_use
            then: min_use * available_resource <= carrier_prod_div_energy_eff <= available_resource
          - else:
            then: carrier_prod_div_energy_eff <= available_resource
        components:
          available_resource:
            - if: resource_unit == energy_per_area
              then: resource * resource_scale * resource_area
            - if: resource_unit == energy_per_cap
              then: resource * resource_scale * energy_cap
            - else:
              then: resource * resource_scale
          carrier_prod_div_energy_eff: carrier_prod / energy_eff

    balance_supply_plus:  # bryn
        foreach: [nodes, techs, carriers, timesteps]
        options:
        - where: [inheritance(supply_plus), and, not include_storage=True]
          eq: resource_con * resource_eff == carrier_prod_incl_losses

        - where: [inheritance(supply_plus), and, not include_storage=True, and, storage_inter_cluster, and, lookup_cluster_first_timestep=True]
          eq: resource_con * resource_eff == carrier_prod_incl_losses

        - where: [inheritance(supply_plus), and, include_storage=True, and, run.cyclic_storage=true, and, timestep = timesteps[0]]
          eq: storage[node, tech, timestep] == ((1 - storage_loss[node, tech]) ** timestep_resolution[previous_step]) * storage[node, tech, previous_step] + resource_con[node, tech, timestep] * resource_eff[node, tech] - carrier_prod_incl_losses
          components:
            previous_step:
                elements: timesteps[-1]
                within: timesteps

        - where: [inheritance(supply_plus), and, include_storage=True, and, not run.cyclic_storage=true, and, timestep = timesteps[0]]
          eq: storage[node, tech, timestep] == storage_initial[node, tech] * storage_cap[node, tech] + resource_con[node, tech, timestep] * resource_eff[node, tech] - carrier_prod_incl_losses

        - where: [inheritance(supply_plus), and, include_storage=True, and, timestep > timesteps[0]]
          eq: storage[node, tech, timestep] == ((1 - storage_loss[node, tech]) ** timestep_resolution[previous_step]) * storage[node, tech, previous_step] + resource_con[node, tech, timestep] * resource_eff[node, tech] - carrier_prod_incl_losses
          components:
            previous_step:
                elements: timesteps[index(timestep) - 1]
                within: timesteps

        - where: [inheritance(supply_plus), and, include_storage=True, and, timestep > timesteps[0], and, clusters, and, lookup_cluster_first_timestep=True]
          eq: storage[node, tech, timestep] == ((1 - storage_loss[node, tech]) ** timestep_resolution[previous_step]) * storage[node, tech, previous_step] + resource_con[node, tech, timestep] * resource_eff[node, tech] - carrier_prod_incl_losses
          components:
            previous_step:
                elements: lookup_cluster_last_timestep[timestep]
                within: timesteps

        components:
            carrier_prod_incl_losses:  # or work out how to do this in a separate constraint
                - if: energy_eff * parasitic_eff == 0
                then: 0
                - if: energy_eff * parasitic_eff > 0
                then: carrier_prod / (energy_eff * parasitic_eff)


    asynchronous_con_milp:
      foreach: [node, tech, timestep]
      eq: -1 * carrier_con_sum <= 1 - prod_con_switch * bigM
      components:
        carrier_con_sum:
          sum: carrier_con
          over: [carrier]

    cost_investment:


