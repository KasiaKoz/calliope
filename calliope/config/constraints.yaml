constraints:


    carrier_production_max: # alice - is that it?
      foreach: [node, tech, timestep]
      eq: carrier_prod <= energy_cap * timestep_resolution * parasitic eff


    balance_supply: # kasia
        foreach: [carrier, node, tech, timestep]
        where: [resource, and, inheritance(supply)]
        eq:
          - if: energy_eff == 0
            then: carrier_prod == 0
          - if: force_resource == 1
            then: carrier_prod_div_energy_eff == available_resource
          - if: min_use
            then: min_use * available_resource <= carrier_prod_div_energy_eff <= available_resource
          - else:
            then: carrier_prod_div_energy_eff <= available_resource
        components:
          available_resource:
            - if: resource_unit == energy_per_area
              then: resource * resource_scale * resource_area
            - if: resource_unit == energy_per_cap
              then: resource * resource_scale * energy_cap
            - else:
              then: resource * resource_scale
          carrier_prod_div_energy_eff: carrier_prod / energy_eff

    # bryn: use 'where' masking to match the constraint subsetting in 'subsets.yaml'
    balance_supply:
        foreach: [node in nodes, tech in techs, carrier in carriers, timestep in timesteps]
        where: [resource, and, inheritance(supply)]
        options:
            - where: [energy_eff=0]
              eq: carrier_prod[node, tech, carrier, timestep] == 0
            - where: [force_resource=True]
              eq: carrier_prod_div_energy_eff == available_resource
            - where: [resource_min_use>0]
              eq: resource_min_use[node, tech] * available_resource <= carrier_prod_div_energy_eff <= available_resource
            - eq: carrier_prod_div_energy_eff <= available_resource
            - where: [resource_unit='energy_per_area']
              components:
                  available_resource:
                      eq: resource[node, tech, timestep] * resource_scale[node, tech] * resource_area[node, tech]
            - where: [resource_unit='energy_per_cap']
              components:
                  available_resource:
                      eq: resource[node, tech, timestep] * resource_scale[node, tech] * energy_cap[node, tech]
            - where: [resource_unit='energy']
              components:
                  available_resource:
                    eq: resource[node, tech, timestep] * resource_scale[node, tech]
        components:
            carrier_prod_div_energy_eff:
                eq: carrier_prod[node, tech, carrier, timestep] / energy_eff[node, tech, timestep]


    # bryn: use 'where' masking to match the constraint subsetting in 'subsets.yaml'
    balance_supply_plus:  # bryn
        foreach: [node in nodes, tech in techs, carrier in carriers, timestep in timesteps]
        options:
            - where: [inheritance(supply_plus), and, not include_storage=True]
              eq: available_resource == carrier_prod_incl_losses

            - where: [inheritance(supply_plus), and, include_storage=True, and, storage_inter_cluster, and, lookup_cluster_first_timestep=True]
              eq: storage[node, tech, timestep] == available_resource - carrier_prod_incl_losses

            - where: [inheritance(supply_plus), and, include_storage=True, and, not run.cyclic_storage=true, and, timestep = timesteps[0]]
              eq: storage[node, tech, timestep] == storage_initial[node, tech] * storage_cap[node, tech] + available_resource - carrier_prod_incl_losses
              components:
                  previous_step:
                      elements: timesteps[-1]
                      within: timesteps

            - where: [inheritance(supply_plus), and, include_storage=True, and, timestep > timesteps[0]]
              eq: storage[node, tech, timestep] == storage_at_timestep_start + available_resource - carrier_prod_incl_losses
              components:
                  previous_step:
                      elements:
                      within: timesteps

            - where: [inheritance(supply_plus), and, include_storage=True, and, timestep > timesteps[0], and, clusters, and, lookup_cluster_first_timestep=True]
              eq: storage[node, tech, timestep] == storage_at_timestep_start + available_resource - carrier_prod_incl_losses
              components:
                  previous_step:
                      elements: lookup_cluster_last_timestep[timestep]
                      within: timesteps
        components:
            carrier_prod_incl_losses:
                - where: [energy_eff=0, or, parasitic_eff=0]
                  eq: 0
                - where: [energy_eff=0, or, parasitic_eff=0]
                  eq: carrier_prod[node, tech, carrier, timestep] / (energy_eff[node, tech, timestep] * parasitic_eff[node, tech, timestep])
            available_resource:
                eq: resource_con[node, tech, timestep] * resource_eff[node, tech]
            storage_at_timestep_start:
                eq: ((1 - storage_loss[node, tech]) ** timestep_resolution[previous_step]) * storage[node, tech, previous_step]

    # bryn: use 'if-else' and refer to all index items explicitly.
    # Then, when an index item is different to that defined in 'foreach'
    # (i.e., 'previous step'), look to 'components' for its definition
    balance_supply_plus:  # bryn
        foreach: [node in nodes, tech in techs, carrier in carriers, timestep in timesteps]
        where: [inheritance(supply_plus)]
        eq:
            - if: include_storage is False
            then: available_resource == carrier_prod_incl_losses
            - if:  include_storage is True and storage_inter_cluster and lookup_cluster_first_timestep is True
            then: storage[node, tech, timestep] == available_resource - carrier_prod_incl_losses
            - else: storage[node, tech, timestep] == storage_at_timestep_start + available_resource - carrier_prod_incl_losses

        components:
            carrier_prod_incl_losses:
                eq:
                    - if: energy_eff == 0 or parasitic_eff == 0
                      then: 0
                    - else: carrier_prod[node, tech, carrier, timestep] / (energy_eff[node, tech, timestep] * parasitic_eff[node, tech, timestep])
            available_resource:
                eq: resource_con[node, tech, timestep] * resource_eff[node, tech]
            storage_at_timestep_start:
                eq:
                    - if: include_storage=True, and, not run.cyclic_storage=true, and, timestep = timesteps[0]
                      then: storage_initial[node, tech] * storage_cap[node, tech]
                    - else: ((1 - storage_loss[node, tech]) ** timestep_resolution[previous_step]) * storage[node, tech, previous_step]
        index_items:
            previous_step:
                eq:
                    - if: include_storage is True and run.cyclic_storage is True and timestep == timesteps[0]
                      then: timesteps[-1]
                    - if: include_storage is True and timestep > timesteps[0]
                      then: timesteps[index(timestep) - 1]  # needs a function 'index' to get the position of 'timestep' in the list 'timesteps' <- could be a lookup table, like below
                    - if: include_storage is True and timestep>timesteps[0] and clusters and lookup_cluster_first_timestep is True
                      then: lookup_cluster_last_timestep[timestep]

    # bryn: use 'if-else' and introduce an explicit reference to a change in index item,
    # which is referred to whenever it overrides on of the 'foreach' dimensions
    balance_supply_plus:
        foreach: [node, tech, carrier, timestep]
        where: [inheritance(supply_plus)]
        eq:
            - if: [include_storage=False]
              then: available_resource == carrier_prod_incl_losses
            - else: storage == storage_at_timestep_start + available_resource - carrier_prod_incl_losses

        components:
            carrier_prod_incl_losses:
                eq:
                    - if: [energy_eff=0, or, parasitic_eff=0]
                      then: 0
                    - else: carrier_prod / (energy_eff * parasitic_eff)
            available_resource:
                eq: resource_con * resource_eff
            storage_at_timestep_start:
                eq:
                    - if: [include_storage=True, and, not run.cyclic_storage=true, and, get_index(timestep)=0]
                      then: storage_initial * storage_cap
                    - if: [include_storage=True, and, storage_inter_cluster, and, lookup_cluster_first_timestep=True]
                      then: 0
                    - else: ((1 - storage_loss[node, tech]) ** timestep_resolution[previous_step]) * storage[node, tech, previous_step]
                    - else: ((1 - storage_loss) ** timestep_resolution[timesteps=previous_step]) * storage[timesteps=previous_step]
                    - else: ((1 - storage_loss) ** select(timestep_resolution, timesteps=previous_step)) * select(storage, timesteps=previous_step)
            previous_step:
                eq:
                    - if: [include_storage=True, and, run.cyclic_storage=True, and, get_index(timesteps)=0]
                      then: get_item(timesteps, -1)
                    - if: [include_storage=True, and, get_index(timesteps)>0]
                      then: get_item(timesteps, get_index(timestep) - 1)  # needs a function 'index' to get the position of 'timestep' in the list 'timesteps' <- could be a lookup table, like below
                    - if: [include_storage=True, and, get_index(timesteps)>0, and, clusters, and, lookup_cluster_first_timestep=True]
                      then: lookup_cluster_last_timestep[timestep]

    asynchronous_con_milp:
      foreach: [node, tech, timestep]
      eq: -1 * carrier_con_sum <= 1 - prod_con_switch * bigM
      components:
        carrier_con_sum:
          sum: carrier_con
          over: [carrier]

    cost_investment:


