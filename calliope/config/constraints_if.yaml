helper_functions:
    get_index:  # in a list, get the position of a value (e.g. get_index(["a", "b"], "a") would return "a"))
    get_item:  # in a list, get a value based on position (e.g. get_item(["a", "b"], 1) would return "b"))
    get_carrier:  # datasets linking technologies to carriers have carrier as a dimension and binary values to say whether a carrier is linked to a technology. So we need a function to grab the carrier name from this dataset.
    sum:  # sum a variable/parameter over one or more of its indexed dimensions
constraints:
    carrier_production_max:
        foreach: [node in nodes, tech in techs, timestep in timesteps]
        where: [carrier, and, not inheritance(conversion_plus), and, not cap_method='integer', and, allowed_carrier_prod=True]
        subset:
            carrier_tiers: [out]  # this is from subsets.py (i.e., we would merge the two)
        eq: "carrier_prod[carrier, node, tech, timestep] <= energy_cap[node, tech] * timestep_resolution[timestep] * parasitic_eff[node, tech, timestep]"


    balance_supply:
        foreach: [carrier in carriers, node in nodes, tech in techs, timestep in timesteps]
        where: [resource, and, inheritance(supply)]
        eq:
          - if: energy_eff[node, tech, timestep] == 0
            then: carrier_prod[carrier, node, tech, timestep] == 0
          - if: force_resource[node, tech] == True
            then: carrier_prod_div_energy_eff == available_resource
          - if: resource_min_use[node, tech]
            then: resource_min_use[node, tech] * available_resource <= carrier_prod_div_energy_eff <= available_resource
          - else: carrier_prod_div_energy_eff <= available_resource
        components:
          available_resource:
            - if: resource_unit[node, tech] == 'energy_per_area'
              then: resource[node, tech, timestep] * resource_scale[node, tech] * resource_area[node, tech]
            - if: resource_unit[node, tech] == 'energy_per_cap'
              then: resource[node, tech, timestep] * resource_scale[node, tech] * energy_cap[node, tech]
            - else: resource[node, tech, timestep] * resource_scale[node, tech]
          carrier_prod_div_energy_eff: carrier_prod[carrier, node, tech, timestep] / energy_eff[node, tech, timestep]

    balance_supply_plus:
        foreach: [carrier in carriers, node in nodes, tech in techs, timestep in timesteps]
        where: [inheritance(supply_plus)]
        eq:
            - if: include_storage[node, tech] == False
              then: available_resource == carrier_prod_incl_losses
              else: storage[node, tech, timestep] == storage_at_timestep_start + available_resource - carrier_prod_incl_losses
        components:
            carrier_prod_incl_losses:
                - if: energy_eff[node, tech] == 0 | parasitic_eff == 0
                  then: 0
                - else: carrier_prod[carrier, node, tech, timestep] / (energy_eff[node, tech, timestep] * parasitic_eff[node, tech, timestep])
            available_resource: resource_con[node, tech, timestep] * resource_eff[node, tech, timestep]
            storage_at_timestep_start:
                - if: include_storage[node, tech] == True & ~run.cyclic_storage == True & get_index(timestep)=0
                  then: storage_initial[node, tech] * storage_cap[node, tech]
                - if: include_storage[node, tech] == True & storage_inter_cluster & lookup_cluster_first_timestep == True
                  then: 0
                - else: ((1 - storage_loss[node, tech]) ** timestep_resolution[previous_step]) * storage[node, tech, previous_step]
        index_items:  # or something else to make it clear that it is different to the "components" of the equation
            previous_step:
                select:
                    - if: include_storage[node, tech] == True & run.cyclic_storage == True & get_index(timesteps)==0
                      then: get_item{timesteps, -1}
                    - if: include_storage[node, tech] == True & get_index(timesteps)>0
                      then: get_item{timesteps, get_index{timestep} - 1}  # could be a lookup table, like below
                    - if: include_storage[node, tech] == True & get_index(timesteps)>0 & clusters & lookup_cluster_first_timestep == True
                      then: lookup_cluster_last_timestep[timestep]
                on_dimension: timesteps

    asynchronous_con_milp:
      foreach: [node in nodes, tech in techs, timestep in timesteps]
      where: [force_asynchronous_prod_con=True]
      eq: -1 * carrier_con[carrier_in, node, tech, timestep] <= 1 - prod_con_switch[node, tech, timestep] * bigM
      index_items:
        carrier_in:
            select: get_carrier{carrier, [node, tech], carrier_tiers="in"}  # "carrier" here refers to a model dataset, which is confusing. Need to deal with this.
            on_dimension: carriers

    cost_investment:
        foreach: [cost in costs, node in nodes, tech in techs]
        where: [[cost_energy_cap, or, cost_om_annual, or, cost_om_annual_investment_fraction, or, cost_purchase, or, cost_resource_area, or, cost_resource_cap, or, cost_storage_cap], and, not run.mode='operate']
        eq: >  # YAML syntax that allows a multiline string that will be parsed as a single line string
            cost_investment[cost, node, tech] =
            cost_om_annual[cost, node, tech] * energy_cap[node, tech] * number_of_years +
            (1 + cost_om_annual_investment_fraction[cost, node, tech]) *
            (cost_energy + cost_resource + cost_storage + cost_area + cost_of_purchase) *
            number_of_years * cost_depreciation_rate[cost, node, tech]
        equation_components:
            cost_energy:
                - if: cost_energy_cap[cost, node, tech]>0
                  then: cost_energy_cap[cost, node, tech] * energy_cap[node, tech]
                - else: 0
            cost_resource:
                - if: cost_resource_cap[cost, node, tech]>0
                  then: cost_resource_cap[cost, node, tech] * resource_cap[node, tech]
                - else: 0
            cost_storage:
                - if: cost_storage_cap[cost, node, tech]>0
                  then: cost_storage_cap[cost, node, tech] * storage_cap[node, tech]
                - else: 0
            cost_area:
                - if: cost_resource_area[cost, node, tech]>0
                  then: cost_resource_area[cost, node, tech] * resource_area[node, tech]
                - else: 0
            cost_of_purchase:
                - if: cap_method[node, tech] == 'binary' & cost_purchase[cost, node, tech]>0
                  then: cost_purchase[cost, node, tech] * purchased[node, tech]
                - if: cap_method[node, tech] == 'integer' & cost_purchase[cost, node, tech]>0
                  then: cost_purchase[cost, node, tech] * units[node, tech]
                - else: 0
            number_of_years: >  # YAML syntax that allows a multiline string that will be parsed as a single line string
                sum{timestep_resolution[timestep], over=timestep in timesteps} *
                sum{timestep_weights[timestep], over=timestep in timesteps} / 8760

    cost_var:
        foreach: [cost in costs, node in nodes, tech in techs, timestep in timesteps]
        where: [cost_energy_cap, or, cost_om_annual, or, cost_om_annual_investment_fraction, or, cost_purchase, or, cost_resource_area, or, cost_resource_cap, or, cost_storage_cap, or, cost_export, or, cost_om_con, or, cost_om_prod]
        eq: cost_var[cost, node, tech, timestep] = (cost_prod + cost_con) * timestep_weights[timestep]
        components:
            cost_prod: cost_om_prod[cost, node, tech, timestep] * carrier_prod[carrier_out, node, tech, timestep]
            cost_con:
                - if: cost_om_con[cost, node, tech, timestep] & inheritance{supply_plus, [node, tech]}
                  then: cost_om_con[cost, node, tech, timestep] * resource_con[node, tech, timestep]
                - if: cost_om_con[cost, node, tech, timestep] & inheritance{supply, [node, tech]} & energy_eff[node, tech, timestep]>0
                  then: cost_om_con[cost, node, tech, timestep] * carrier_prod[carrier_out, node, tech, timestep] / energy_eff[node, tech, timestep]
                - if: cost_om_con[cost, node, tech, timestep] & ~inheritance{supply, [node, tech]} & ~inheritance{supply_plus, [node, tech]}
                  then: cost_om_con[cost, node, tech, timestep] * -1 * carrier_con[carrier_in, node, tech, timestep]
                - else: 0
        index_items:
            carrier_out:
                select:
                    - if: inheritance{conversion_plus, [node, tech]}
                      then: get_carrier{primary_carrier_out, [node, tech]}
                    - else: get_carrier{carrier, [node, tech], carrier_tiers="out"} # "carrier" here refers to a model dataset, which is confusing. Need to deal with this.
                on_dimension: carriers

            carrier_in:
                select:
                    - if: inheritance{conversion_plus, [node, tech]}]
                      then: get_carrier{primary_carrier_in}
                    - else: get_carrier{carrier, [node, tech], carrier_tiers="in"} # "carrier" here refers to a model dataset, which is confusing. Need to deal with this.
                on_dimension: carriers
